# 莫比乌斯反演

## 前言

本文参考pengym的[莫比乌斯反演](https://www.cnblogs.com/peng-ym/p/8647856.html)，讲得极好

## 莫比乌斯函数

### 定义

对于整数$d$，我们先对其进行质因数分解：
$$
d = \prod_{i=1}^{m} p_i^{k_i}
$$
其中$p_i$为互不相等的质数，以此为前提，莫比乌斯函数$\mu(d)$的定义是：
$$
\mu(d) = \begin{cases} {
1 \\[1pt]
(-1)^m \\[2pt]
0
}\quad { if \ d =1\\
 if\ \forall i \in \left\{1, 2,\cdots,m\right\},\ k_i =1\\
 if\ \exist i\in \left\{1,2,\cdots,m\right\},\ k_i >= 2
}
\end{cases}
$$
用人话说就是如果$d$等于1，莫比乌斯函数$\mu(d)$的值就是1；如果$d$分解得到的质因数的幂次都是1，则$\mu(d)$由分解得到的质因数的个数决定；否则如果存在某个质因数的幂次大于等于2，则$\mu(d)=0$

很容易看出所有质数$p$的$\mu(p)=-1$

### 性质

限于笔者的水平十分有限，下面只列出了笔者理解了的两个性质，有没有其他性质笔者也没有深入了解，如果有读者还了解其他性质，欢迎在评论区留言~~说的会有人看一样~~

- 对于$\forall n \in N^+$，有
    $$
    \sum_{d|n} \mu(d)=[n==1],
    $$
    可以把$[n==1]$看作为一个布尔表达式，它返回$true$或$false$，只有当$n=1$时，$n$的因数的莫比乌斯函数之和为1，否则和为0

    **瞎*儿证明一下：**

    因为$n=p_1^{k_1}*p_2^{k_2}*\cdots*p_m^{k_m}$，哪些数是$n$的因数呢？我们可以这么想，对于质因数$p_i$，我们可以取$0,1,2,\cdots,k_i$个，所以$n$有$(k_1+1)*(k_2+1)*\cdots*(k_m+1)$个因数，也就是说$T_1$式子中的$d$有$(k_1+1)*(k_2+1)*\cdots*(k_m+1)$这么多种取值，而我们要求这些$d$对应的$\mu$值再对它们求和。

    根据$\mu(x)$的定义，任何质因数的幂次大于等于2时，$\mu(x)=0$，也就是说每个质因数我们最多取一次，因为取两次或以上得到的$\mu$为0，不会对求和产生影响。我们令$Y=p_1*p_2*\cdots*p_m$，则$\sum\limits_{d|n}\mu(d) = 1*C_m^{0} + (-1)^1*C_m^1+\cdots+(-1)^m*C_m^m$，由二项式定理我们可得$1*C_m^{0} + (-1)^1*C_m^1+\cdots+(-1)^m*C_m^m = (-1 +1)^m=0^m$，当$m==0$时，即$n==1$时，$\sum\limits_{d|n}\mu(d)=1$；其他情况$\sum\limits_{d|n}\mu(d)=0$

- 莫比乌斯函数$\mu(d)$是积性函数，即若$\gcd(n,m)=1$，则$\mu(nm)=\mu(n)\mu(m)$，这个性质用定义稍微想想就出来了

- 对于$\forall n \in N^+$，有
    $$
    \sum_{d|n} \frac{\mu(d)}{d}=\frac{\varphi(n)}{n},
    $$
    其中$\phi(n)$是欧拉函数，定义是$[1,n-1]$内与$n$互质数的个数

    **瞎*儿证明一下：**

    欧拉函数有一个性质：

    
    $$
    \varphi(n) = n * (1-\frac{1}{p_1}) * (1-\frac{1}{p_2})*\cdots*(1-\frac{1}{p_m})
    $$
(PS:关于这个性质的理解可以移步[数论初步](https://blog.csdn.net/weixin_44563427/article/details/104522688)，不过那篇巨长，读者可以去欧拉定理那块去找
    
    有了这一性质就好办了，右式
    $$
    \frac{\varphi(n)}{n}=(1-\frac{1}{p_1}) * (1-\frac{1}{p_2})*\cdots*(1-\frac{1}{p_m})
    $$
    关于左边的和式中$d$，每个质因数最多选一次，因为取两次或以上相乘得到的$d$的莫比乌斯函数$\mu(d)=0$，再根据$\mu(d)$的定义可以得到下面的式子
    $$
    \sum_{d|n} \frac{\mu(d)}{d}=1+(-1)^1*(\frac{1}{p_1}+\frac{1}{p_2}+\cdots+\frac{1}{p_m})\\+(-1)^2*(\frac{1}{p_1p_2}+\frac{1}{p_1p_3}+\dots+\frac{1}{p_1p_m}+\frac{1}{p_2p_3}+\frac{1}{p_2p_4}+\cdots +\frac{1}{p_{m-1}p_m})\\+\cdots+(-1)^m*\frac{1}{p_1p_2 \cdots p_m}
    $$
    稍微想想就能发现上面两个式子其实就是相等的，于是这个性质也口糊完了

### 线性筛莫比乌斯函数

基本上是根据定义筛出来的，和性质没啥大的关系

```c++
void get_mu(int n) {
    mu[1] = 1; check[1] = true;
    for(int i = 2; i <= n; i++) {
        if(!check[i])
            prime[++tot] = i, mu[i] = -1;
        for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
			check[i * prime[j]] = 1;
            if(i % prime[j]) mu[i * prime[j]] = -mu[i];
            else {
                mu[i * prime[j]] = 0;
                break;
            }
        }
    }
}
```

## 莫比乌斯反演

终于到了本文的重点，莫比乌斯反演定理~~当然前面的内容也很重要~~

### 定理内容

$F(n)$和$f(n)$为定义在正整数集合上的两个函数，如果它们满足
$$
F(n)=\sum_{d|n}f(d)=\sum_{d|n}f(\frac{n}{d})
$$
那么可得
$$
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})=\sum_{d|n}\mu(\frac{n}{d})F(d)
$$
而且这个条件是**充要的**

在看证明之前可以先列几项感受一下：
$$
\begin{array} {}
{F(1)=f(1)\\
F(2)=f(1)+f(2)\\
F(3)=f(1)+f(3)\\
F(4)=f(1)+f(2)+f(4)\\
\cdots}
{\qquad}{f(1)=F(1)\\
f(2)=F(2)-F(1)\\
f(3)=F(3)-F(1)\\
f(4)=F(4)-F(2)\\
\cdots
}
\end{array}
$$

### 证明

#### 充分性

由已知条件
$$
F(n)=\sum_{d|n}f(d)=\sum_{d|n}f(\frac{n}{d})
$$
所以
$$
{\sum_{d|n}\mu(d)F(\frac{n}{d})\\
=\sum_{d|n}(\mu(d)\sum_{i|\frac{n}{d}}f(i))\\
=\sum_{d|n}\sum_{i|\frac{n}{d}}\mu(d)f(i)\\
=\sum_{i|n}\sum_{d|\frac{n}{i}}\mu(d)f(i)\\
=\sum_{i|n}(f(i)\sum_{d|\frac{n}{i}}\mu(d))
}{\qquad}
{(1) \\[1.15cm]
(2) \\[1.15cm]
(3) \\[1.15cm]
(4) \\[1.15cm]
(5)
}
$$
PS:由(3)式推到(4)式可以想象一个二重循环，(4)式分别相当于把二重循环的内部循环拿出来变成外部循环，原来的外部循环变成内部循环，只是改变了一下求和的顺序

由莫比乌斯函数的第一条性质
$$
\sum_{d|\frac{n}{i}} \mu(d)=[\frac{n}{i}==1]
$$
只有当$i=n$时，才能使布尔表达式$[\frac{n}{i}==1]$为真，使得$\mu(d)=1$，其他情况$\mu(d)=0$，也就是说
$$
\sum_{i|n}(f(i)\sum_{d|\frac{n}{i}}\mu(d))=f(n)+\underbrace{0+0+\cdots+0}_{n的因数个数-1}=f(n)
$$
所以我们得到
$$
\sum_{d|n}\mu(d)F(\frac{n}{d})=f(n)
$$

#### 必要性

必要性的证明和充分性类似，限于篇幅，不予证明

### 回到莫比乌斯函数

看完莫比乌斯反演我们可以反过来看看上面莫比乌斯函数的第三条性质
$$
\sum_{d|n} \frac{\mu(d)}{d}=\frac{\varphi(n)}{n}
$$
我们令$F(n)=n,f(n)=\phi(n)$，由于欧拉函数有一个性质
$$
n=\sum_{d|n}\varphi(d)
$$
也就是$F(n)=\sum_{d|n}f(d)$，那么由莫比乌斯反演定理，有
$$
\varphi(n)=f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})=\sum_{d|n}\mu(d)\frac{n}{d}
$$
稍微移项就得到
$$
\sum_{d|n} \frac{\mu(d)}{d}=\frac{\varphi(n)}{n}
$$

## 例题

- [洛谷P3455 **ZAP-queries**](https://www.luogu.com.cn/problem/P3455)

    **题意：** 给定$n,m,d$，问$\sum\limits_{x=1}^n\sum\limits_{y=1}^m[gcd(x,y)==d]$，$[]$里是一个布尔表达式

    **思路(具体思路参考下一题的思路，下一题是本题的加强版)：** 不妨令$n\leq m$，把$d$除掉，记$n'=\left\lfloor n/d\right\rfloor,m'=\left\lfloor m/d\right\rfloor$，原式化为$\sum\limits_{x=1}^{n'}\sum\limits_{y=1}^{m'}[gcd(x,y)==1]$，式子化为
    $$
    \sum_{x=1}^{n'}\sum_{y=1}^{m'}\sum_{d|\gcd(x,y)}\mu(d)
    $$
    将$d$提前，原式化为
    $$
    \sum_{d=1}^{n'} \mu(d)*\left\lfloor \frac{n'}{d} \right\rfloor * \left\lfloor \frac{m'}{d} \right\rfloor
    $$
    注意到$\left\lfloor \frac{n}{d} \right\rfloor * \left\lfloor \frac{m}{d} \right\rfloor$可以数论分块(数论分块不会的话移步[数论初步](https://blog.csdn.net/weixin_44563427/article/details/104522688))，只不过这里的每一块要求$\left\lfloor\frac{n'}{d}\right\rfloor*\left\lfloor\frac{m'}{d}\right\rfloor$相等，而$\sum\limits_{d=1}^{n'}\mu(d)$可以用前缀和$O(1)$地求

    **代码：**

    ```cpp
    #include <cstdio>
    #include <iostream>
    const int N = 5e4+5;
    typedef long long ll;
    
    int n, m, d, tot;
    int prime[N >> 1], mu[N];
    ll sum[N];
    bool check[N];
    
    inline int min(int x, int y) { return x < y ? x : y; }
    
    void get_mu(int n) {
        mu[1] = 1; check[1] = true;
        for(int i = 2; i <= n; i++) {
            if(!check[i])
                prime[++tot] = i, mu[i] = -1;
            for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
    			check[i * prime[j]] = 1;
                if(i % prime[j]) mu[i * prime[j]] = -mu[i];
                else {
                    mu[i * prime[j]] = 0;
                    break;
                }
            }
        }
        for(int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + mu[i];
    }
    
    ll calc() {
        ll res = 0;
        for(int l = 1, r = 0; l <= n; l = r + 1) {
            r = min((n / (n / l)), (m / (m / l)));
            res += (sum[r] -  sum[l - 1]) * (n / l) * (m / l);
        }
        return res;
    }
    
    int main() {
        int t; scanf("%d", &t);
        get_mu(N - 5);
        while(t--) {
            scanf("%d%d%d", &n, &m, &d);
            if(n > m) std::swap(n, m);
            n /= d, m /= d;
            printf("%lld\n", calc());
        }
        return 0;
    }
    ```

- [洛谷P2257 **YY的GCD**](https://www.luogu.com.cn/problem/P2257)

    **题意：** 给定$n,m$，问$\sum\limits_{x=1}^n\sum\limits_{y=1}^m[gcd(x,y)==prime]$，$[]$里是一个布尔表达式，其中$prime$是任意质数

    **思路：** 对于一个固定的质数，我们像上一题一样把它除掉就行了，姑且将这个质数记为$k$，需要枚举$k$，显然$k \leq n$。令$n\leq m$，记$P=\left\{p\ |\ p\ is\ prime,p\leq n \right\}$，原式化为
    $$
    \sum_{k\in P}\sum_{x=1}^{\left\lfloor n/k \right\rfloor}\sum_{y=1}^{\left\lfloor m/k \right\rfloor}[gcd(x,y)==1]
    $$
    根据性质一
    $$
    \sum_{d|n}\mu(d)=[n==1]
    $$
    得到
    $$
    [gcd(x,y)==1]=\sum\limits_{d|\gcd(x,y)}\mu(d)
    $$
    问题转化为求
    $$
    \sum_{k\in P}\sum_{x=1}^{\left\lfloor n/k \right\rfloor}\sum_{y=1}^{\left\lfloor m/k \right\rfloor}\sum_{d|\gcd(x,y)}\mu(d)
    $$
    将和式换序，由于$d \in [1,n]$，将$d$提前后，$i,j$均为$d$的倍数，原式进一步化简化为
    $$
    \sum_{k\in P} \sum_{d=1}^{\left\lfloor n/k \right\rfloor} \mu(d)*\left\lfloor \frac{n}{kd} \right\rfloor * \left\lfloor \frac{m}{kd} \right\rfloor
    $$
    令$kd=T$，$2\leq T\leq n$，再将$T$提前，先枚举$T$，原式化为
    $$
    \sum_{T=2}^{n}\left\lfloor \frac{n}{T} \right\rfloor * \left\lfloor \frac{m}{T} \right\rfloor \sum_{k|T,k\in P}\mu(\frac{T}{k})
    $$
    注意到$\left\lfloor\frac{n}{T}\right\rfloor*\left\lfloor\frac{m}{T}\right\rfloor$可以数论分块，关键在于我们要求出$\sum\limits_{k|T,k\in P}\mu(\frac{T}{k})$的前缀和，只要求出前缀和数组$sum[]$，我们就能$O(\sqrt n)$地算出上面的式子了

    记$sum[T]=\sum\limits_{i=1}^T \sum\limits_{k|i,k\in P} \mu(\frac{i}{k})$，记$\sum\limits_{k|i,k\in P} \mu(\frac{i}{k})=g[i]$，则$sum[i]=sum[i-1]+g[i]$。要求出$g[i]$，我们枚举每个质数$k$，对每个质数枚举它的倍数，然后求和就行了

    细节看代码$\Downarrow$

    **代码**：

    ```cpp
    #include <cstdio>
    #include <iostream>
    const int N = 1e7 + 5;
    typedef long long ll;
    
    int tot;
    int mu[N], prime[N >> 2];
    ll g[N], sum[N];
    bool check[N];
    
    void get_mu(int n) {
        mu[1] = 1; check[1] = true;
        for(ll i = 2; i <= n; i++) {
            if(!check[i])
                mu[i] = -1, prime[++tot] = i;
            for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
                check[i * prime[j]] = true;
                if(i % prime[j]) mu[i * prime[j]] = -mu[i];
                else {
                    mu[i * prime[j]] = 0;
                    break;
                }
            }
        }
        for(int i = 1; i <= tot; i++)
            for(int j = 1; j * prime[i] <= n; j++)
                g[j * prime[i]] += (ll)mu[j];
        for(int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + g[i];
    }
    
    inline int min(int x, int y) { return x < y ? x : y; }
    
    ll calc(int n, int m) {
        ll res = 0L;
        for(int l = 1, r = 0; l <= n; l = r + 1) {
            r = min(n / (n / l), m / (m / l));
            res += (sum[r] - sum[l - 1]) * (n / l) * (m / l);
        }
        return res;
    }
    
    int main() {
        get_mu(N - 5);
        int t;
        scanf("%d", &t);
        while(t--) {
            int n, m;
            scanf("%d%d", &n, &m);
            if(n > m) std::swap(n, m);
            printf("%lld\n", calc(n, m));
        }
        return 0;
    }
    ```

    **总结：** 大家可能感觉没莫比乌斯反演什么事情，用莫比乌斯函数的性质就能做，没有直接使用莫比乌斯反演，如果想看反演怎么做，可以查看洛谷的题解，最上面的一篇就是pengym写的，他的讲解很详细

- [洛谷 P2522 **[HAOI]Problem b**](https://www.luogu.com.cn/problem/P2522)

    **题意：** 给定$a,b,c,d,k$，问$\sum\limits_{x=a}^b\sum\limits_{y=c}^d[gcd(x,y)==k]$，$[]$里是一个布尔表达式

    **思路：** 做完第一题后，这题基本就没啥东西了，我们可以利用容斥定理，
    $$
    ans[a,b][c,d]=ans[1,b][1,d]-ans[1,a-1][1,b]\\-ans[1,b][1,c-1]+ans[1,a-1][1,c-1]
    $$
    然后调用四次第一题的函数就行了，需要注意的是区间左右端点除$k$时需要处理一下，不能包含多余的左边界

    **代码：** 此题的main函数部分，其他部分基本不需要改动

    ```cpp
    int main() {
        int t; scanf("%d", &t);
        get_mu(N - 5);
        while(t--) {
            scanf("%d%d%d%d%d", &a, &b, &c, &d, &k);
            if(a > b) std::swap(a, b);
            if(c > d) std::swap(c, d);
            if(a % k) {
                a /= k;
                a++;
            } else a /= k;
            if(c % k) {
                c /= k;
                c++;
            } else c /= k;
            b /= k, d /= k;
            printf("%lld\n", calc(b, d) - calc(a - 1, d) - calc(b, c - 1) + calc(a - 1, c - 1));
        }
        return 0;
    }
    ```
    
- [洛谷3327 P3327 **[SDOI]约数和个数**](https://www.luogu.com.cn/problem/P3327)

    **题意：** 给定$n,m$，求$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}d(i*j)$，其中$d(x)$为$x$的约数个数
$$
    d(i*j)=\sum_{x|i}\sum_{y|j}[\gcd(x,y) == 1]
$$


## 总结

莫比乌斯的代码一般都不是很长~~只是笔者没遇到巨长的题~~，工作量主要是推式子，如果能静下心来好好反演，应该可以做出来题~~不是~~

顺便推荐：[An_Account的博客](https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi)，有很多变式讲得很清楚