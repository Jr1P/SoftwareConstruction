# 杜教筛

## 积性函数

对于[**数论函数**]([https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/8555075?fr=aladdin](https://baike.baidu.com/item/数论函数/8555075?fr=aladdin))$f(x)$，如果对于任意满足$\gcd(x,y)=1$的$x,y$，有$ f(x\cdot y)=f(x)\cdot f(y)$，则称$f(x)$为**积性函数**；如果去掉互质的条件仍能满足后面的性质成立，则称$f(x)$为**完全积性函数**

常见的几个积性函数：

1. $\mu(n)$——莫比乌斯函数，在[莫比乌斯反演](https://blog.csdn.net/weixin_44563427/article/details/104722695)讲过了
2. $\varphi(n)$——欧拉函数，表示$[1,n-1]$中与$n$互质的数的个数($[1,n]$也一样的，反正$n$和$n$也不互质)
3. $d(n)$——约数个数，表示$n$的约数个数，$d(n)=\sum\limits_{d|n}1=\sum\limits_{d=1}^{n}[d|n]$
4. $\sigma(n)$——约数和函数，表示$n$的各个约数之和，$\sigma(n)=\sum\limits_{d|n}d=\sum\limits_{d=1}^{n}[d|n]*d$

常见的几个**完全**积性函数：

1. $\epsilon(n)$——元函数，只有$n=1$时函数值为1，其他情况为0，$\epsilon(n)=[n==1]$
2. $I(n)$——恒等函数，函数值恒为1
3. $id(n)$——单位函数，$id(n)=n$

积性函数还有一个重要的性质：积性函数$*$积性函数仍为积性函数

## 狄利克雷卷积

### 定义

两个数论函数$f$和$g$的卷积为$(f*g)(n) = \sum\limits_{d|n}f(d) \cdot g(\dfrac{n}{d})$，读作$f$卷$g$，其实读$g$卷$f$也是一样的，因为有定义很容易看出狄利克雷卷积有交换律(本文中的'$*$'均为狄利克雷卷积，'$\cdot$'为通常的乘法)

### 性质

1. 交换律：$f*g=g*f$
2. 结合律：$(f*g)*h=f*(g*h)$
3. 分配律：$(f+g)*h=f*h+g*h$，严格来讲是卷积运算对'+'运算满足分配律

读者们看到$\epsilon(n)$可能觉得这种函数啥用？从近世代数的角度看，记所有数论函数的集合为$S$，$S$和狄利克雷卷积$*$就构成了一个代数系$(S,*)$，而$\epsilon(n)$就是这个代数系的单位元，由于狄利克雷卷积$*$满足结合律和交换律，所以$(S,*)$是个**可换半群**，再加上单位元，$(S,*,\epsilon)$就是一个**可换幺半群**，至于它是否为一个群在此不作讨论(近世代数的内容看不懂也没关系，不影响后面的内容，笔者也只是刚学一点，而且学得极烂)

那狄利克雷卷积有什么用？它可以用来证明一些性质：

- 莫比乌斯函数$\mu$

    莫比乌斯函数有一个重要性质：$\sum\limits_{d|n}\mu(d)=[n==1]$，下面我们用狄利克雷卷积证明莫比乌斯反演：

    ----

    由已知得
    $$
    F(n) = \sum\limits_{d|n}f(d)，
    $$
    等价于$F=f*I$，两边同时卷积莫比乌斯函数$\mu$，得
    $$
    F*\mu=(f*I)*\mu
    $$
    由结合律得
    $$
    {F*\mu\\
    =(f*I)*\mu\\
    =f*(I*\mu)\\
    =f*\sum_{d|n}I(d)\cdot \mu(\dfrac{n}{d})\\
    =f*\sum_{d|n}\mu(\dfrac{n}{d})
    }
    $$
    再根据$\mu$的性质$\sum\limits_{d|n}\mu(d)=[n==1]$，上式又化为$f*\epsilon$，就等于$f$，所以就有
    $$
    f=F*\mu=\sum_{d|n}F(d)\cdot\mu(\dfrac{n}{d})
    $$

    ----

    采用狄利克雷卷积的证明简单易懂，比之前的和式变换直观许多

- 欧拉函数$\varphi $

    欧拉函数有一个重要的性质：$\sum\limits_{d|n}\varphi(d) = n$，用它和狄利克雷卷积，我们可以证明莫比乌斯函数的一个性质：$\dfrac{\varphi(n)}{n}=\sum\limits_{d|n}\dfrac{\mu(d)}{d}$
    
    ----
    
    由已知
    $$
    \sum_{d|n}\varphi(d) = n
    $$
    将它表示为狄利克雷卷积形式：$\varphi*I=id$，式子两边同时卷$\mu$，得
    $$
    \varphi*I*\mu=id*\mu\\
    \iff \varphi*\epsilon=id*\mu\\
    \iff \varphi=id*\mu
    $$
    所以$\varphi(n)=\sum\limits_{d|n}\mu(d)\cdot\dfrac{n}{d}$，移项得
    $$
    \dfrac{\varphi(n)}{n} = \sum_{d|n} \dfrac{\mu(d)}{d}
    $$
    
    ----

## 杜教筛

看完前面的内容，终于要开始杜教筛了！首先，我们应该清楚一个问题：杜教筛到底是用来干什么的？杜教筛是以低于线性时间复杂度计算出**积性函数前缀和**的筛法。

也就是说我们要求$\sum\limits_{i=1}^n f(i)$，其中$f(i)$是积性函数，我们姑且记$\sum\limits_{i=1}^nf(i)=S(n)$

为了解决上面的问题，我们构造两个积性函数$h$和$g$，使得$h=f*g$，下面我们开始求$\sum\limits_{i=1}^n h(i)$
$$
\begin{aligned}
\sum_{i=1}^n h(i) & =\sum_{i=1}^n\sum_{d|i}g(d)\cdot f(\dfrac{i}{d})\\
& = \sum_{d=1}^n g(d)\cdot \sum_{i=1}^{\left\lfloor \tfrac{n}{d}\right\rfloor} f(i)\\
& = \sum_{d=1}^ng(d)\cdot S(\left\lfloor \frac{n}{d} \right\rfloor)
\end{aligned}
$$
接着，将和式的第一项提出来，得到
$$
g(1)\cdot S(n)=\sum_{i=1}^n h(i) - \sum_{d=2}^n g(d)\cdot S(\left\lfloor \frac{n}{d} \right\rfloor)
$$
这样，如果$h(i)$前缀和能很快地求出，对后面的式子利用分块(不过$g(d)$也要能快速求和，且$d$从2开始，不是从1开始)，可以将求$S(n)$的复杂度降到$O(n^{\frac{2}{3}})$。杜教筛的套路就是找到一个$g$，使得$f*g=h$的前缀和能简单求出，顺便$g$的求和也简单。**注意：**杜教筛不像线性筛，比如线性筛筛$\varphi、\mu$这些函数一遍筛就把$[1,n]$的都筛出来，而杜教筛是只筛出$S(n)$，不过从上面的式子很容易就想到递归求解的方式，可以把递归时求出的一些$S(\left\lfloor\dfrac{n}{d}\right\rfloor)$保存下来，这样可以筛得快一些(因为数组没法开到1e9那种级别，可以用个map来存筛出来的$S$)。一般前几项直接按照线性筛的筛法筛出来(积性函数有个性质——能被$O(n)$筛出来)，然后$O(n)$求一遍前缀和来算；后面的项用上面的式子，拿杜教筛筛

来点例子：

- 求$S(n)=\sum\limits_{i=1}^n \mu(i)$

    这里的$f=\mu$，现在的目标是找一个$g$，使得$f$卷$g$得到的函数很好求前缀和，顺便$g$也要比较好求和，从上文我们已经得到一个结论：$\mu*I=\epsilon$，而$\epsilon$的前缀和很好求，就是1，所以有
    $$
    S(n)=1-\sum_{d=2}^n S(\left\lfloor\frac{n}{d}\right\rfloor)
    $$

- 求$S(n)=\sum\limits_{i=1}^{n}\varphi(i)$

    由欧拉函数的性质，我们知道$(\varphi*I)(n)=n$，也就是$\varphi*I=id$，$id$求和很简单，所以有
    $$
    S(n)=\sum_{i=1}^n i-\sum_{d=2}^n S(\left\lfloor\frac{n}{d}\right\rfloor)
    $$

- 求$S(n)=\sum\limits_{i=1}^n i\cdot \varphi(i)$

    这个式子乍一看难找$g$来和$f$卷，这时候我们就回到狄利克雷卷积的定义，我们要找的是$h=f*g$使得$h$的前缀和比较好求，而$(f*g)(n) = \sum\limits_{d|n}(d\cdot \varphi(d))\cdot g(\dfrac{n}{d})$。现在的问题就是前面的$d$在这不好求，如果用$g$能约掉就好了，我们发现$g(\dfrac{n}{d})$的分母有个$d$，那么令$g=id$，那么$h(n)=\sum\limits_{d|n}\varphi(d)\cdot n=n\cdot\sum\limits_{d|n} \varphi(d)=n^2$，所以有
    $$
    S(n)=\sum_{i=1}^n i^2-\sum_{d=2}^nd\cdot S(\left\lfloor \frac{n}{d} \right\rfloor)
    $$
    再根据$\sum\limits_{i=1}^n i^2=\dfrac{n(n+1)(2n+1)}{6} $，就能筛了

## 板子

- [洛谷P4213 **【模板】杜教筛(Sum)**](https://www.luogu.com.cn/problem/P4213)

    ```cpp
    #include <cstdio>
    #include <map>
    #define N 5000010
    typedef long long ll;
    
    bool check[N];
    int mu[N], sum_mu[N], phi[N], prime[N >> 2], tot;
    ll sum_phi[N];
    std::map<int, int> map_mu;
    std::map<int, ll> map_phi;
    
    void get(int n) {
    	phi[1] = mu[1]= 1; check[1] = true;
    	for(int i = 2; i <= n; i++) {
            if(!check[i]) prime[++tot] = i, mu[i] = -1, phi[i] = i - 1;
            for(int j = 1; j <= tot && i * prime[j] <= n; j++) {
                check[i * prime[j]] = true;
                if(i % prime[j] == 0) {
                    mu[i * prime[j]] = 0;
                    phi[i * prime[j]] = phi[i] * prime[j];
                    break;
                } else {
                    mu[i * prime[j]] = -mu[i];
                    phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                }
            }
    	}
        for(int i = 1; i <= n; i++)
            sum_mu[i] = sum_mu[i - 1] + mu[i], sum_phi[i] = sum_phi[i - 1] + phi[i];
    }
    
    int djmu(int n) {
        if(n < N) return sum_mu[n];
        if(map_mu.count(n)) return map_mu[n];
        int ans = 1;
        for(int l = 2, r = 0; l <= n; l = r + 1) {
            r = n / (n / l);
            ans -= (r - l + 1) * djmu(n / l);
        }
        map_mu.insert(std::make_pair(n, ans));
        return ans;
    }
    
    ll djphi(int n) {
        if(n < N) return sum_phi[n];
        if(map_phi.count(n)) return map_phi[n];
        ll ans = (ll)(n + 1) * n >> 1;
        for(int l = 2, r = 0; l <= n; l = r + 1) {
            r = n / (n / l);
            ans -= (ll)(r - l + 1) * djphi(n / l);
        }
        map_phi.insert(std::make_pair(n, ans));
        return ans;
    }
    
    int main() {
        get(N - 1);
        int t;
        scanf("%d", &t);
        while(t--) {
            int n;
            scanf("%d", &n);
            printf("%lld %d\n", djphi(n), djmu(n));
        }
        return 0;
    }
    ```

    




