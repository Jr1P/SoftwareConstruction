# 树上差分

## 点差分

问题描述：给定一棵带点权的树$T$，给定$q$个操作$(q \leq 1e6)$，每次操作给定$u, v, x$，将路径$(u, v)$上的每一个点的点权都加上$x$，**最后**(注意是**最后**)询问每个点的点权

点差分可以做到$O(\log(n))$的时间复杂度完成对一条路径的操作，最后用$dfs$遍历一遍求前缀和求出每个点的点权($dfs$的时候先到叶子，从叶子节点向上更新权值)

利用差分可以将一次路径操作变为：

```cpp
diff[u] += x; diff[v] += x;
diff[LCA(u, v)] -= x;
diff[father(LCA(u, v))] -= x;
```

## 边差分

问题基本和点差分一致，只是点权变成了边权，只要把边权存给儿子节点就可以了，然后一次修改就变为下面的操作：

```cpp
diff[u] += x; diff[v] += x;
diff[LCA(u, v)] -= x << 1;
```

## 板子

- [洛谷 P3128 **Max Flow P**](https://www.luogu.com.cn/problem/P3128)

```cpp
#include <cstdio>
#include <iostream>
#define N 50005
#define DEPTH 18

struct Edge {
    int v, next;
}e[N << 1];

int fa[N][21], depth[N], head[N], diff[N];
int n, m, cnt, ans;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return x;
}

void init() {
    for(int i = 1; i <= n; i++)
        head[i] = -1;
}

inline void add(int u, int v) {
    e[++cnt] = Edge{v, head[u]};
    head[u] = cnt;
}

void dfs(int u) {
    for(int i = 1; i <= DEPTH; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(fa[u][0] != v) {
            fa[v][0] = u;
            depth[v] = depth[u] + 1;
            dfs(v);
        }
    }
}

int LCA(int u, int v) {
    if(depth[u] < depth[v]) std::swap(u, v);
    for(int det = depth[u] - depth[v], i = 0; det; det >>= 1, i++)
        if(det & 1) u = fa[u][i];
    if(u == v) return u;
    for(int i = DEPTH; i >= 0; i--)
        if(fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    return fa[u][0];
}

void dfs2(int u) {
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(v == fa[u][0]) continue;
        dfs2(v);
        diff[u] += diff[v];
    }
    ans = std::max(ans, diff[u]);
}

int main() {
    scanf("%d%d", &n, &m); init();
    for(int i = 1; i < n; i++) {
        int u = read(), v = read();
        add(u, v); add(v, u);
    }
    depth[fa[1][0] = 0] = 0;
    dfs(1);
    for(int i = 1; i <= m; i++) {
        int u, v, anc;
        u = read(); v = read();
        diff[u]++; diff[v]++;
        diff[anc = LCA(u, v)]--; diff[fa[anc][0]]--;
    }
    dfs2(1);
    printf("%d\n", ans);
    return 0;
}
```

## 例题

- [洛谷 P3258 [JLOI2014]**松鼠的新家**](https://www.luogu.com.cn/problem/P3258)

```cpp
#include <cstdio>
#include <iostream>
const int N = 3e5 + 5;
const int DEPTH = 19;

struct Edge {
    int v, nxt;
} e[N << 1];

int n, cnt, ans, s;
int head[N], fa[N][20], diff[N], depth[N], vis[N];

inline void add(int u, int v) {
    e[++cnt] = Edge{v, head[u]};
    head[u] = cnt;
}

void dfs1(int u) {
    for(int i = 1; i <= DEPTH; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for(int i = head[u]; i != -1; i = e[i].nxt) {
        int v = e[i].v;
        if(fa[u][0] == v) continue;
        depth[v] = depth[u] + 1;
        fa[v][0] = u;
        dfs1(v);
    }
}

int LCA(int u, int v) {
    if(depth[u] < depth[v]) std::swap(u, v);
    for(int det = depth[u] - depth[v], i = 0; det; det >>= 1, i++)
        if(det & 1) u = fa[u][i];
    if(u == v) return u;
    for(int i = DEPTH; i >= 0; i--) {
        if(fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

void dfs2(int u) {
    for(int i = head[u]; i != -1; i = e[i].nxt) {
        int v = e[i].v;
        if(fa[u][0] == v) continue;
        dfs2(v);
        diff[u] += diff[v];
    }
}

int main() {
    scanf("%d%d", &n, &s);
    fa[s][0] = 0;
    for(int i = 1; i <= n; i++) head[i] = -1;
    for(int i = 1; i < n; i++) scanf("%d", &vis[i]);
    for(int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v); add(v, u);
    }
    dfs1(s);
    int anc = LCA(s, vis[1]);
    diff[s]++, diff[vis[1]]++;
    diff[anc]--, diff[fa[anc][0]]--;
    for(int i = 1; i < n - 1; i++) {
        int u = vis[i], v = vis[i + 1];
        anc = LCA(u, v);
        if(anc == u) {
            diff[v]++, diff[u]--;
            continue;
        } else if(anc == v) {
            diff[fa[u][0]]++, diff[fa[v][0]]--;
            continue;
        }
        diff[fa[u][0]]++;
        diff[v]++;
        diff[anc]--, diff[fa[anc][0]]--;
    }
    dfs2(s);
    for(int i = 1; i <= n; i++)
        if(i == vis[n - 1])
            printf("%d\n", diff[i] - 1);
        else
            printf("%d\n", diff[i]);
    return 0;
}
```

- [洛谷 P2680 **运输计划**](https://www.luogu.com.cn/problem/P2680)

