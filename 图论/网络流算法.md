# 网络流算法

## 最大流

### Dinic算法

上界为$O(n^2m)$，随机数据跑得比这个要快得多

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
#define N 10250
#define M 120050
#define INF 0x7fffffff

struct Edge {
    int v, w, next;
}e[M<<1];

int n, m, cnt = -1, s, t;
int head[N], depth[N], cur[N];

inline int min(int x, int y) { return (x < y)? x: y; }

inline int read() {
    int x = 0;
    char c = getchar();
    bool flag = 0;
    while(c < '0' || c > '9') {
   		if(c == '-')
   			flag = 1;
   		c = getchar();
   	}
    while(c >= '0' && c <= '9') {
    	x = (x << 3) + (x << 1) + (c ^ 48);
    	c = getchar();
    }
    return flag ? -x : x;
}

inline void add(int u, int v, int w) {
    e[++cnt].w = w;
    e[cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

bool bfs(int s, int t) {
    for(int i = 0; i <= n; i++) depth[i] = -1;
    std::queue<int > q;
    q.push(s);
    depth[s] = 0;
    while(!q.empty()) {
        int now = q.front(), v;
        q.pop();
        for(int i = head[now]; i != -1; i = e[i].next) {
            v = e[i].v;
            if(depth[v] == -1 && e[i].w) {
                q.push(v);
                depth[v] = depth[now] + 1;
            }
        }
    }
    if(depth[t] == -1) return false;
    else return true;
}

int dfs(int u, int flow) {
    if(u == t) return flow;
    int v, nowflow, sumflow = 0; //nowflow为当前流的流量, sumflow为流量之和
    for(int& i = cur[u]; i != -1; i = e[i].next) {
        v = e[i].v;
        if(depth[v] == depth[u] + 1 && e[i].w) {
            nowflow = dfs(v, min(flow, e[i].w));
            flow -= nowflow;
            e[i].w -= nowflow;
            e[i ^ 1].w += nowflow;
            sumflow += nowflow;
            if(!flow) break;
        }
    }
    if(sumflow == 0) depth[u] = -1;
    return sumflow;
}

void Dinic() {
    int maxflow = 0;
    while(bfs(s, t)) {
        for(int i = 1; i <= n; i++)
            cur[i] = head[i];
        maxflow += dfs(s, INF);
    }
    printf("%d\n", maxflow);
}

int main() {
    memset(head, -1, sizeof(head));
    n = read(), m = read(), s = read(), t = read();
    for(int i = 1; i <= m; i++) {
        int u = read(), v = read(), w = read();
        add(u, v, w);
        add(v, u, 0);
    }
    Dinic();
    return 0;
}
```

### ISAP预流推进

上界也是$O(n^2m)$，随机数据也是比这个要快得多

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <queue>
#include <vector>
#include <algorithm>
const int N = 1e4 + 5;
const int M = 1.2e5 + 5;
const int INF = 0x3fffffff;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar())
        if (c == '-') f = -1;
    for (; isdigit(c); c = getchar())
        x = (x << 3) + (x << 1) + (c ^ '0');
    return x * f;
}

struct Edge {
    int v, w, nxt;
} e[M << 1];
int tot = -1, n, m, s, t;
int h[N], gap[N], cur[N], d[N];
std::vector<int> inv[N];

void add(int u, int v, int w) {
    e[++tot] = (Edge){v, w, h[u]};
    h[u] = tot;
    e[++tot] = (Edge){u, 0, h[v]};
    h[v] = tot;
}

std::queue<int > q;
void init() {
    memset(gap, 0, sizeof gap), memset(d, 0, sizeof d);
    ++gap[d[t] = 1];
    for (int i = 1; i <= n; ++i) cur[i] = h[i];
    q.push(t);
    while (q.empty()) {
        int x = q.front(); q.pop();
        for (int i = h[x], v = e[i].v; i != -1; i = e[i].nxt, v = e[i].v)
            if (!d[v])
                ++gap[d[v] = d[x] + 1], q.push(v);
    }
}
int aug(int u, int mi) {
    if (u == t) return mi;
    int flow = 0;
    for (int &i = cur[u], v = e[i].v; i != -1; i = e[i].nxt, v = e[i].v)
        if (d[u] == d[v] + 1) {
            int tmp = aug(v, std::min(mi, e[i].w));
            flow += tmp, mi -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp;
            if (!mi) return flow;
        }
    if (!(--gap[d[u]])) d[s] = n + 1;
    ++gap[++d[u]], cur[u] = h[u];
    return flow;
}

int ISAP() {
    init();
    int ret = aug(s, INF);
    while (d[s] <= n) ret += aug(s, INF);
    return ret;
}

int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);
    tot = 1; memset(h, -1, sizeof h);
    for (int i = 1; i <= n; ++i)
        inv[i].clear();
    for (int i = 1; i <= m; ++i) {
        int u = read(), v = read(), w = read();
        add(u, v, w);
        inv[v].push_back(u);
    }
    int ans = ISAP();
    printf("%d\n", ans);
    return 0;
}
```

### HLPP最高标号预流推进



## 最小费用最大流

就是把$bfs$改成$spfa$了

```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>
#define N 5050
#define M 50050
#define INF 0x3fffffff

struct Edge {
    int u, v, next, flow, cost; // cost 单位流量费用, flow 最大流量
    Edge() {}
    Edge(int u, int v, int next, int flow, int cost)
        : u(u), v(v), next(next), flow(flow), cost(cost) {}
} e[M << 1];

int n, m, s, t, cnt = 0;
int head[N], dis[N], pre[N], a[N];
bool inque[N];

inline int min(int x, int y) { return x < y ? x : y; }

inline void add(int u, int v, int flow, int cost) {
    e[cnt] = Edge(u, v, head[u], flow, cost);
    head[u] = cnt++;
}

bool SPFA(int s, int t) {
    std::queue<int> q;
    for (int i = 1; i <= n; i++) {
        dis[i] = INF;
        inque[i] = false;
    }
    a[s] = INF;
    q.push(s);
    pre[s] = dis[s] = 0;
    inque[s] = true;
    while (!q.empty()) {
        int now = q.front();
        q.pop(); inque[now] = false;
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v;
            if (dis[now] + e[i].cost < dis[v] && e[i].flow > 0) {
                dis[v] = dis[now] + e[i].cost;
                pre[v] = i;
                a[v] = min(a[now], e[i].flow);
                if (!inque[v]) {
                    q.push(v);
                    inque[v] = true;
                }
            }
        }
    }    
    return dis[t] != INF;
}

int MCMF() {
    int flow = 0, cost = 0;
    while (SPFA(s, t)) {
        flow += a[t];
        cost += dis[t] * a[t];
        int u = t;
        while (u != s) {
            e[pre[u]].flow -= a[t];
            e[pre[u] ^ 1].flow += a[t];
            u = e[pre[u]].u;
        }
    }
    printf("%d %d\n", flow, cost);
}

int main() {
    memset(head, -1, sizeof(head));
    scanf("%d%d%d%d", &n, &m, &s, &t);
    for (int i = 1; i <= m; i++) {
        int u, v, flow, cost;
        scanf("%d%d%d%d", &u, &v, &flow, &cost);
        add(u, v, flow, cost);
        add(v, u, 0, -cost);
    }
    MCMF();
    return 0;
}

```

