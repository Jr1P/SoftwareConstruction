## 欧拉回路(路径)

### 概念

对于图$G(V,E)$，有如下的定义：

- 欧拉路径：图$G$中**不重复地**经过每条边一次的**路径**称为欧拉路径
- 欧拉回路：图$G$中**不重复地**经过每条边一次的**回路**称为欧拉回路
- 欧拉图：存在欧拉回路的图称为欧拉图
- 半欧拉图：存在欧拉路径的图称为半欧拉图

### 性质

- **无向图$G$**为欧拉图 $\iff G$为连通图且所有顶点的度为偶数

- **无向图$G$**为半欧拉图 $\iff G$为连通图且顶点的度为奇数的点只有两个

- **有向图$G$**为欧拉图 $\iff G$的**基图**连通且所有$G$的所有顶点的入度等于出度

    (啥是基图？有向图$G$的基图是指将$G$中的所有有向边变为无向边后的图)

- **有向图$G$**为半欧拉图 $\iff G$的**基图**连通且仅存在一对顶点$(u,v)$，$u$的入度比出度大1，$v$的出度比入度小1，其他顶点的入度和出度都相同

先判断是否符合存在欧拉回路(路径)  
1. 奇点个数
2. 联通性  
  
### __Fleury算法__

如果找回路则从哪一点开始都行, 如果找欧拉路径则从两奇点中的一个开始  
思想: 从奇点开始dfs, 因为只有两个奇点, 其他点的度数为偶数, 一进一出, 必然不会出现"走进去出不来"的情况; 我们一直搜直到发现走进去出不来, 这时这个点必为奇点, 且没有路可以走了, 我们将栈顶(即这个奇点)输出, 然后回溯，每回溯到一个点都判断这个点是否还能走其他边，如果不能走的话，我们就输出这个点，然后再回溯，一直到一个点有其他边可以走，我们就把这个pop，但是不输出，然后再重新从这个点开始dfs  
喜闻乐见板子 👇👇👇

``` cpp
#include <cstdio>
#include <stack>
#include <cstring>
#define mem(a, b) memset(a, b, sizeof(a))
#define N 10050
#define M 100050
// 编号0～n-1
struct Edge {
    int w, nxt, v;
}e[N];
int n, m, cnt;
int head[N], du[N];
bool vis[N], pass[M];

std::stack<int > s;

inline void add(int u, int v, int w) {
    e[cnt].v = v;
    e[cnt].w = w;
    e[cnt].nxt = head[u];
    head[u] = cnt++;
}

void check(int u) { //是否有欧拉路径
    vis[u] = true;
    for(int i = head[u]; i != -1; i = e[i].nxt) {
        int v = e[i].v;
        if(vis[v]) continue;
        check(v);
    }
}

void dfs(int u) {
    s.push(u);
    for(int i = head[u]; i != -1; i = e[i].nxt) {
        if(pass[i]) continue;
        pass[i] = pass[i ^ 1] = true;
        dfs(e[i].v);
        break;
    }
}

void fleury(int st) {
    s.push(st);
    while(!s.empty()) {
        bool flag = false;
        int u = s.top(); s.pop();
        for(int i = head[u]; i != -1; i = e[i].nxt) {
            if(pass[i]) continue;
            flag = true; break;
        }
        if(!flag) printf("%d ", u);
        else dfs(u);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) head[i] = -1, vis[i] = false;
    int u, v, w;
    for(int i = 0; i < m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w), du[u]++;
        add(v, u, w), du[v]++;
    }
    int oddNum = 0;
    u = 0;
    for(int i = 0; i < n; i++)
        if(du[i] & 1) oddNum++, u = i; //存在奇点时u是奇点
    if(oddNum != 0 && oddNum != 2) {
        puts("No Euler Way...");
        return 0;
    }
    while(!s.empty()) s.pop();
    check(0);
    bool flag = true;
    for(int i = 0; i < n; i++)
        if(!vis[i]) {
            flag = false;
            break;
        }
    if(!flag) { //连通性
        puts("No Euler Way...");
        return 0;
    }
    fleury(u);
    return 0;
}
```