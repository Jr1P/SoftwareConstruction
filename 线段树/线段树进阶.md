# 线段树进阶

## 前置技能

那还用说？当然是线段树，如果读者还不了解线段树这种数据结构，[$\rightarrow$传送门$\leftarrow$](https://www.cnblogs.com/Jr1Preg/p/12337141.html)

## 区间加 + 区间求$\gcd$


$$
\gcd(a, b) = \gcd(a-b, b) \\
{\gcd(a_l, a_{l+1},\dots,a_r)\\= \gcd(a_l, a_{l+1}-a_l, a_{l+2}-a_{l+1},\dots,a_r-a_{r-1})\\= \gcd(\gcd(a_{l+1}-a_l, a_{l+2}-a_{l+1},\dots, a_r-a_{r-1}), a_l)}\\
$$

- [HDU 5726 **GCD**](http://acm.hdu.edu.cn/showproblem.php?pid=5726)



## 扫描线

### 矩形面积并

<img src="https://img-blog.csdn.net/20160727191935932?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="矩形面积并" style="zoom:67%;" />

图片地址：https://blog.csdn.net/tomorrowtodie/article/details/52048323

```cpp
#include <cstdio>
#include <algorithm>
#define ls (k << 1)
#define rs (ls | 1)
const int N = 205;

struct Seg {
    double l, r, h;
    int d;
    Seg() {}
    Seg(double _l, double _r, double _h, int _d) : l(_l), r(_r), h(_h), d(_d) {}
    bool operator < (const Seg &a) const {
        return h < a.h;
    }
}seg[N];

struct Node {
    int l, r, cnt;
    double sum;
}node[N << 2];

int n, x, y, d;
double corx[N];

void build(int l, int r, int k) {
    node[k].l = l; node[k].r = r; node[k].cnt = node[k].sum = 0;
    if(l == r)
        return ;
    int mid = (l + r) >> 1;
    build(l, mid, ls);
    build(mid + 1, r, rs);
}

void update(int k) {
    if(node[k].cnt) node[k].sum = corx[node[k].r + 1] - corx[node[k].l];
    else if(node[k].l == node[k].r) node[k].sum = 0;
    else node[k].sum = node[ls].sum + node[rs].sum;
}

void work(int k) {
    if(node[k].l >= x && node[k].r <= y) {
        node[k].cnt += d;
        update(k);
        return ;
    }
    int mid = (node[k].l + node[k].r) >> 1;
    if(x <= mid) work(ls);
    if(y > mid) work(rs);
    update(k);
}

int main() {
    int kase = 0;
    while(~scanf("%d", &n)) {
        if(!n) break;
        for(int i = 1; i <= n; i++) {
            double x1, x2, y1, y2;
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            corx[i] = x1; corx[n + i] = x2;
            seg[i] = Seg(x1, x2, y1, 1);
            seg[i + n] = Seg(x1, x2, y2, -1);
        }
        n <<= 1;
        std::sort(corx + 1, corx + n + 1);
        std::sort(seg + 1, seg + n + 1);
        int sz = std::unique(corx + 1, corx + n + 1) - corx - 1;
        double ans = 0;
        build(1, sz, 1);
        for(int i = 1; i < n; i++) {
            x = std::lower_bound(corx + 1, corx + sz + 1, seg[i].l) - corx;
            y = std::lower_bound(corx + 1, corx + sz + 1, seg[i].r) - corx - 1;
            d = seg[i].d;
            work(1);
            ans += (seg[i + 1].h - seg[i].h) * node[1].sum;
        }
        printf("Test case #%d\nTotal explored area: %.2f\n\n", ++kase, ans);
    }
    return 0;
}
```

